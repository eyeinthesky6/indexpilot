# IndexPilot Configuration File
# This file controls system features, bypass settings, and operational parameters

# System Bypass Configuration
bypass:
  # Level 1: Feature-Level Bypasses (Granular Control)
  features:
    # Auto-indexing system
    auto_indexing:
      enabled: true
      reason: ""  # Optional: reason for current state
    
    # Query statistics collection
    stats_collection:
      enabled: true
      reason: ""
    
    # Expression profile checks
    expression_checks:
      enabled: true
      reason: ""
    
    # Mutation logging
    mutation_logging:
      enabled: true
      reason: ""
  
  # Level 2: Module-Level Bypass
  modules:
    # Disable all optimization features
    optimization_features:
      enabled: true
      reason: ""
  
  # Level 3: System-Level Bypass (Complete)
  system:
    # Complete system bypass
    enabled: false
    reason: ""
    # When enabled, uses direct database connections
    use_direct_connections: true
  
  # Level 4: Startup Bypass
  startup:
    # Skip system initialization entirely
    skip_initialization: false
    reason: ""
  
  # Emergency Bypass (Runtime Override)
  emergency:
    # Emergency disable all features
    enabled: false
    reason: ""
    # Auto-recovery after specified seconds (0 = manual recovery)
    auto_recover_after_seconds: 0

# System Configuration
system:
  database:
    host: "localhost"
    port: 5432
    name: "indexpilot"
    user: "indexpilot"
    # password: ""  # Never in config file, use DB_PASSWORD environment variable
  
  connection_pool:
    min_connections: 2
    max_connections: 20
  
  query:
    timeout_seconds: 30
  
  maintenance:
    interval_seconds: 3600
  
  logging:
    level: "INFO"  # DEBUG, INFO, WARNING, ERROR, CRITICAL

# Feature-Specific Configuration
features:
  auto_indexer:
    # Mode: "apply" (create indexes, default) or "advisory" (log only, no creation)
    mode: apply
    # Cost-benefit threshold multiplier (higher = less aggressive)
    threshold_multiplier: 1.0
    # Minimum queries per hour to consider indexing
    min_queries_per_hour: 100
    # Maximum indexes per table
    max_indexes_per_table: 10
    # Test mode: reduces thresholds to force algorithm execution (testing only, do not use in production)
    algorithm_test_mode: false
    # Threshold reduction factor in test mode (0.1 = 10x reduction, 0.2 = 5x reduction, etc.)
    algorithm_test_threshold_reduction: 0.1
  
  auto_indexing:
    # Cost-benefit threshold multiplier (higher = less aggressive)
    threshold_multiplier: 1.0
    # Minimum queries per hour to consider indexing
    min_queries_per_hour: 100
    # Maximum indexes per table
    max_indexes_per_table: 10
  
  stats_collection:
    # Batch size for stats flushing
    batch_size: 100
    # Flush interval in seconds
    flush_interval_seconds: 5
    # Maximum buffer size
    max_buffer_size: 10000
  
  expression_profiles:
    # Default field expression (if no profile exists)
    default_expression: true
    # Cache expression checks (performance optimization)
    cache_enabled: true
    cache_ttl_seconds: 300

  # Query Interceptor Configuration
  query_interceptor:
    # Maximum allowed query cost (blocks queries exceeding this)
    max_query_cost: 10000.0
    # Maximum allowed cost for sequential scans
    max_seq_scan_cost: 1000.0
    # Maximum allowed planning time in milliseconds
    max_planning_time_ms: 100.0
    # Enable/disable query blocking
    enable_blocking: true
    # Enable/disable rate limiting check
    enable_rate_limiting: true
    # Enable/disable plan analysis cache
    enable_plan_cache: true
    # Plan cache TTL in seconds (5 minutes default)
    plan_cache_ttl: 300
    # Maximum number of cached query plans
    plan_cache_max_size: 1000
    # Query preview length for logging (characters)
    query_preview_length: 200
    # Safety score thresholds (0.0-1.0)
    safety_score_unsafe_threshold: 0.3
    safety_score_warning_threshold: 0.7
    # Safety score penalty factors
    safety_score_high_cost_penalty: 0.5
    safety_score_seq_scan_penalty: 0.7
    safety_score_nested_loop_penalty: 0.8

  # Auto-Indexer Cost Configuration
  auto_indexer:
    # Mode: "apply" (create indexes, default) or "advisory" (log only, no creation)
    # In advisory mode, candidate indexes are logged to mutation_log but not created
    # In apply mode, indexes are automatically created when beneficial
    mode: "apply"  # Change to "advisory" to disable automatic index creation
    # Cost estimation constants
    build_cost_per_1000_rows: 1.0
    query_cost_per_10000_rows: 1.0
    min_query_cost: 0.1
    # Index type cost multipliers (relative to standard index)
    index_type_costs:
      partial: 0.5
      expression: 0.7
      standard: 1.0
      multi_column: 1.2
    # Field selectivity thresholds
    min_selectivity_for_index: 0.01  # At least 1% distinct values
    high_selectivity_threshold: 0.5   # >50% distinct = high selectivity
    # Performance measurement
    min_improvement_pct: 20.0  # Require at least 20% improvement
    sample_query_runs: 5       # Number of runs for performance measurement
    # Query plan analysis
    use_real_query_plans: true
    min_plan_cost_for_index: 100.0
    # Table size thresholds
    small_table_row_count: 1000
    medium_table_row_count: 10000
    # Small table thresholds
    small_table_min_queries_per_hour: 1000
    small_table_max_index_overhead_pct: 50.0
    # Medium table thresholds
    medium_table_max_index_overhead_pct: 60.0
    # Large table cost adjustment
    large_table_cost_reduction_factor: 0.8  # 20% reduction for large tables
    # Maintenance window wait threshold (seconds)
    max_wait_for_maintenance_window: 3600  # 1 hour
    # CERT (Cardinality Estimation Restriction Testing) Configuration
    # Based on "CERT: Continuous Evaluation of Cardinality Estimation" arXiv:2306.00355
    cert_max_error_pct: 10.0  # Maximum acceptable error percentage for cardinality estimates
    # EXPLAIN Integration Settings (Deep EXPLAIN Integration Enhancement)
    explain_usage_tracking_enabled: true  # Enable tracking of EXPLAIN usage coverage
    min_explain_coverage_pct: 70.0  # Minimum EXPLAIN coverage required (warn if below)

  # CPU Throttling Configuration
  cpu_throttle:
    # CPU usage threshold (don't create indexes if CPU > this)
    cpu_threshold: 80.0
    # Cooldown period after high CPU (seconds)
    cpu_cooldown: 30.0
    # Maximum CPU during index creation (abort if exceeded)
    max_cpu_during_creation: 95.0
    # Minimum delay between index creations (seconds)
    min_delay_between_indexes: 60.0
    # CPU monitoring window (seconds)
    cpu_monitoring_window: 60
    # CPU check interval during cooldown (seconds)
    cpu_check_interval: 5.0
    # Maximum wait time for CPU cooldown (seconds)
    max_cooldown_wait: 300

  # Dynamic Memory Configuration (Auto-adjusting PostgreSQL memory based on available RAM)
  memory_config:
    # Percentage of available RAM to use for PostgreSQL (default: 50%)
    memory_percent: 50.0
    # Minimum memory to allocate (MB) - safety floor
    min_memory_mb: 512
    # Maximum memory to allocate (MB) - safety ceiling
    max_memory_mb: 8192
    # Enable automatic memory adjustment based on available RAM
    auto_adjust_enabled: true

  # Rate Limiting Configuration
  rate_limiter:
    # Query rate limits
    query:
      max_requests: 1000
      time_window_seconds: 60.0  # 1000 queries per minute
    # Index creation rate limits
    index_creation:
      max_requests: 10
      time_window_seconds: 3600.0  # 10 indexes per hour
    # Connection rate limits
    connection:
      max_requests: 100
      time_window_seconds: 60.0  # 100 connections per minute

  # Constraint Programming for Index Selection
  # Multi-objective optimization considering storage, performance, workload, and tenant constraints
  constraint_optimization:
    enabled: true  # Toggle: enable/disable constraint programming (default: true - enabled)
    min_score_threshold: 0.5  # Minimum constraint score (0.0-1.0) to approve index creation
    storage:
      max_per_tenant_mb: 1000.0  # Maximum storage per tenant in MB
      max_total_mb: 10000.0  # Maximum total storage in MB
      warn_threshold_pct: 80.0  # Warning threshold percentage
    performance:
      max_query_time_ms: 100.0  # Maximum acceptable query time in milliseconds
      min_improvement_pct: 20.0  # Minimum performance improvement percentage
    workload:
      read_write_ratio: 0.8  # Target read/write ratio (0.0-1.0)
      max_write_overhead_pct: 10.0  # Maximum write performance overhead percentage
    tenant:
      max_indexes_per_tenant: 50  # Maximum indexes per tenant
      max_indexes_per_table: 10  # Maximum indexes per table

# Production Safeguards Configuration
production_safeguards:
  # Maintenance Windows - Toggle + Config (expensive - delays index creation)
  maintenance_window:
    enabled: true  # Toggle: enable/disable maintenance window enforcement
    start_hour: 2
    end_hour: 6
    days_of_week: [0, 1, 2, 3, 4, 5, 6]  # All days (0=Monday, 6=Sunday)
  
  # Write Performance - Toggle + Config (DB-breaking - limits index creation)
  write_performance:
    enabled: true  # Toggle: enable/disable write performance monitoring
    max_indexes_per_table: 10
    warn_indexes_per_table: 7
    write_overhead_threshold: 0.2  # 20%

# Operational Features Configuration
operational:
  # Health Checks - Toggle (operational overhead)
  health_checks:
    enabled: true  # Toggle: enable/disable health check endpoints
  
  # Maintenance Tasks - Toggle (operational overhead)
  maintenance_tasks:
    enabled: true  # Toggle: enable/disable maintenance tasks
    # interval_seconds is already configurable via MAINTENANCE_INTERVAL env var
  
  # Reporting - Toggle (expensive - runs queries)
  reporting:
    enabled: true  # Toggle: enable/disable reporting generation
  
  # Schema Evolution - Toggle (DB-breaking - alters schema)
  schema_evolution:
    enabled: true  # Toggle: enable/disable schema evolution features

  # Statistics Refresh - Automatic ANALYZE operations
  statistics_refresh:
    enabled: true  # Toggle: enable/disable automatic statistics refresh
    interval_hours: 24  # How often to check for stale statistics
    stale_threshold_hours: 24  # Hours since last ANALYZE to consider stale
    min_table_size_mb: 1.0  # Minimum table size to check (skip small tables)
    auto_refresh_after_bulk_ops: true  # Auto-refresh after bulk operations

  # Foreign Key Index Suggestions
  foreign_key_suggestions:
    enabled: true  # Toggle: enable/disable foreign key index suggestions

  # Index Cleanup Configuration
  index_health:
    enabled: true  # Toggle: enable/disable index health monitoring (default: true)
    bloat_threshold: 20.0  # Bloat threshold percentage (default: 20%)
    min_size_mb: 1.0  # Minimum index size to monitor in MB (default: 1MB)
    auto_reindex: false  # Toggle: enable/disable automatic REINDEX for bloated indexes (default: false - requires explicit enable for safety)
    reindex_schedule: "weekly"  # REINDEX schedule: "weekly", "monthly", or "on_demand" (default: "weekly")
    reindex_require_maintenance_window: true  # Require maintenance window for REINDEX (default: true - safer)
    # Safety limits for automatic REINDEX (prevents resource exhaustion)
    reindex_max_indexes_per_run: 5  # Maximum indexes to REINDEX per run (default: 5, safety limit)
    reindex_max_size_mb: 1000.0  # Maximum size of individual index to REINDEX automatically (default: 1000MB = 1GB)
    reindex_max_total_size_mb: 5000.0  # Maximum total size of all indexes to REINDEX per run (default: 5000MB = 5GB)
    reindex_max_time_seconds: 3600  # Maximum time for REINDEX operations per run (default: 3600s = 1 hour)
    # Note: REINDEX is resource-intensive. Safety limits prevent:
    # - Too many indexes reindexed at once (max_indexes_per_run)
    # - Very large indexes causing long operations (max_size_mb)
    # - Excessive total I/O impact (max_total_size_mb)
    # - Long-running operations blocking maintenance (max_time_seconds)
    # Enable auto_reindex only if you have maintenance windows configured and understand the impact

  index_cleanup:
    enabled: true  # Toggle: enable/disable index cleanup detection
    auto_cleanup: false  # Toggle: enable/disable automatic cleanup (default: false for safety)
  index_lifecycle:
    enabled: true  # Toggle: enable/disable index lifecycle management integration
    weekly_schedule: true  # Enable weekly lifecycle operations
    monthly_schedule: true  # Enable monthly lifecycle operations
    per_tenant_management: true  # Enable per-tenant lifecycle management
    vacuum_analyze_integration: true  # Enable VACUUM ANALYZE for tables with indexes
    vacuum_timeout_seconds: 300.0  # Timeout for VACUUM operations (default: 5 minutes)
    auto_reindex_enabled: false  # Enable automatic REINDEX (conservative default)
    statistics_refresh_enabled: true  # Enable statistics refresh during lifecycle
    cleanup_enabled: true  # Enable index cleanup during lifecycle
    consolidation_enabled: false  # Enable index consolidation suggestions (disabled by default for safety)
    covering_index_enabled: false  # Enable covering index analysis (disabled by default for safety)
    min_scans: 10  # Minimum scans to consider index as used
    days_unused: 7  # Days without scans to consider unused
  
  # Query Timeout Management
  query_timeout:
    enabled: true  # Enable query timeout management
    default_query_timeout_seconds: 30.0  # Default timeout for queries (30 seconds)
    default_statement_timeout_seconds: 60.0  # Default timeout for statements (60 seconds)
  
  # Index Retry Logic
  index_retry:
    enabled: true  # Toggle: enable/disable automatic retry on failures
    max_retries: 3  # Maximum number of retry attempts
    initial_delay_seconds: 5.0  # Initial delay before retry
    max_delay_seconds: 60.0  # Maximum delay between retries
    backoff_multiplier: 2.0  # Exponential backoff multiplier
    retryable_errors:  # List of error keywords that are retryable
      - timeout
      - connection
      - lock
      - deadlock
      - temporary
      - resource

  # Redundant Index Detection
  redundant_index_detection:
    enabled: true  # Toggle: enable/disable redundant index detection

  # Workload Analysis
  workload_analysis:
    enabled: true  # Toggle: enable/disable workload analysis
    time_window_hours: 24  # Time window for workload analysis
    read_heavy_threshold: 0.7  # Read ratio >= 0.7 = read-heavy
    write_heavy_threshold: 0.3  # Write ratio >= 0.3 = write-heavy

  # Storage Budget Management
  storage_budget:
    enabled: true  # Toggle: enable/disable storage budget management
    max_storage_per_tenant_mb: 1000.0  # Maximum index storage per tenant (MB)
    max_storage_total_mb: 10000.0  # Maximum total index storage (MB)
    warn_threshold_pct: 80.0  # Warn when usage exceeds this percentage

  # Auto-Rollback on No Improvement
  auto_rollback:
    enabled: false  # Toggle: enable/disable automatic rollback (default: false for safety)
    rollback_on_negative: true  # Rollback if improvement is negative
    rollback_on_below_threshold: false  # Rollback if improvement below threshold (not just negative)

  # Concurrent Index Monitoring
  concurrent_index_monitoring:
    enabled: true  # Toggle: enable/disable concurrent index build monitoring
    check_interval_seconds: 30  # How often to check build progress
    alert_on_hanging_seconds: 3600  # Alert if build takes longer than this (1 hour)

  # Materialized View Support
  materialized_view_support:
    enabled: true  # Toggle: enable/disable materialized view index suggestions

  # Structured Logging
  structured_logging:
    enabled: false  # Toggle: enable/disable JSON structured logging (default: false)
    format: "json"  # Format: "json" or "text"
    include_context: true  # Include context in log entries
    include_stack_trace: false  # Include stack traces in log entries

  # Per-Tenant Configuration
  per_tenant_config:
    enabled: true  # Toggle: enable/disable per-tenant configuration

  # Approval Workflow
  approval_workflow:
    enabled: false  # Toggle: enable/disable approval workflow (default: false)
    require_approval: false  # Require approval for all index creations
    auto_approve_threshold: 0.9  # Auto-approve if confidence >= 0.9
    notification_enabled: false  # Enable email/Slack notifications

  # QPG (Query Plan Guidance) - Phase 1 Algorithm
  qpg:
    enabled: true  # Toggle: enable/disable QPG enhancement (default: true)
    diverse_plan_generation: true  # Generate diverse query plans
    bottleneck_analysis_depth: 3  # Depth for bottleneck analysis recursion
    identify_logic_bugs: true  # Identify potential logic bugs in plans

  # Cortex (Data Correlation Exploitation) - Phase 1 Algorithm
  cortex:
    enabled: true  # Toggle: enable/disable Cortex enhancement (default: true)
    correlation_threshold: 0.7  # Minimum correlation score (0.0-1.0) to suggest composite index
    min_correlation_samples: 100  # Minimum samples needed for correlation calculation
    use_mutual_information: true  # Use mutual information for correlation (if available)
    sample_size: 10000  # Sample size for correlation analysis

  # Predictive Indexing (ML Utility Prediction) - arXiv:1901.07064
  predictive_indexing:
    enabled: true  # Toggle: enable/disable Predictive Indexing ML enhancement (default: true)
    weight: 0.3  # Weight of ML prediction vs heuristic (0.0-1.0, higher = more ML influence)
    min_historical_samples: 10  # Minimum historical samples needed for historical prediction
    use_historical_data: true  # Use historical index performance data if available

  # ALEX (Adaptive Learned Index) - arXiv:1905.08898
  # Note: PostgreSQL doesn't natively support learned indexes, but this provides
  # workload analysis and recommendations for dynamic/write-heavy workloads.
  # When ALEX strategy is recommended, appropriate PostgreSQL index types are suggested
  # that provide similar benefits (better write performance, adaptive behavior).
  alex:
    enabled: true  # Toggle: enable/disable ALEX analysis (default: true)
    write_heavy_threshold: 0.3  # Write ratio >= this threshold = write-heavy workload
    dynamic_workload_threshold: 0.4  # Minimum dynamic score to recommend ALEX strategy
    min_queries_for_alex: 100  # Minimum queries needed for ALEX analysis
    min_table_size_for_alex: 1000  # Minimum table size (rows) for ALEX consideration

  # RadixStringSpline (RSS) - arXiv:2111.14905
  # Note: PostgreSQL doesn't natively support learned indexes, but this provides
  # analysis and recommendations for string fields that would benefit from RSS-like behavior.
  # When RSS strategy is recommended, appropriate PostgreSQL index types are suggested
  # that provide similar benefits (memory-efficient indexing, fast string lookups).
  radix_string_spline:
    enabled: true  # Toggle: enable/disable RSS analysis (default: true)
    min_table_size: 1000  # Minimum table size (rows) for RSS consideration
    min_cardinality_ratio: 0.1  # Minimum cardinality ratio (distinct/total) to recommend RSS
    min_avg_string_length: 10  # Minimum average string length (chars) for RSS consideration
    min_suitability_score: 0.5  # Minimum RSS suitability score (0.0-1.0) to recommend RSS strategy

  # Fractal Tree (Write-Optimized Index)
  # Note: PostgreSQL doesn't natively support Fractal Tree indexes, but this provides
  # analysis and recommendations for write-heavy workloads that would benefit from
  # Fractal Tree-like write-optimized behavior. When Fractal Tree strategy is recommended,
  # appropriate PostgreSQL index strategies are suggested (fewer indexes, partial indexes, etc.)
  # that provide similar write-optimization benefits.
  fractal_tree:
    enabled: true  # Toggle: enable/disable Fractal Tree analysis (default: true)
    write_heavy_threshold: 0.4  # Write ratio >= this threshold = write-heavy workload
    min_queries: 100  # Minimum queries needed for Fractal Tree analysis
    min_table_size: 10000  # Minimum table size (rows) for Fractal Tree consideration
    min_suitability_score: 0.5  # Minimum Fractal Tree suitability score (0.0-1.0) to recommend Fractal Tree strategy

  # PGM-Index (Learned Index) - arXiv:1910.06169
  # Note: PostgreSQL doesn't natively support learned indexes, but this provides
  # suitability analysis and recommendations. When PGM-Index is recommended,
  # a B-tree index is created with notes about learned index benefits.
  pgm_index:
    enabled: false  # Toggle: enable/disable PGM-Index analysis (default: false)
    min_rows: 10000  # Minimum table rows for PGM-Index consideration
    min_suitability: 0.5  # Minimum suitability score (0.0-1.0) to recommend PGM-Index
    build_cost_per_1000_rows: 0.8  # Build cost per 1000 rows (relative to B-tree)
    compression_ratio: 0.3  # Estimated compression ratio vs B-tree (0.3 = 70% space savings)

  # iDistance (Multi-Dimensional Indexing)
  # Note: PostgreSQL doesn't natively support iDistance indexes, but this provides
  # analysis and recommendations for multi-dimensional query patterns.
  idistance:
    enabled: true  # Toggle: enable/disable iDistance analysis (default: true)
    min_table_rows: 1000  # Minimum table rows for iDistance consideration
    min_suitability: 0.5  # Minimum suitability score (0.0-1.0) to recommend iDistance strategy

  # Bx-tree (Moving Objects/Temporal Indexing)
  # Note: PostgreSQL doesn't natively support Bx-tree indexes, but this provides
  # analysis and recommendations for temporal query patterns that would benefit from
  # Bx-tree-like temporal indexing behavior.
  bx_tree:
    enabled: true  # Toggle: enable/disable Bx-tree analysis (default: true)
    min_table_size: 10000  # Minimum table size (rows) for Bx-tree consideration
    min_temporal_queries: 50  # Minimum temporal queries for Bx-tree analysis
    min_suitability_score: 0.5  # Minimum Bx-tree suitability score (0.0-1.0) to recommend Bx-tree strategy

  # XGBoost Pattern Classification - arXiv:1603.02754
  xgboost:
    enabled: true  # Toggle: enable/disable XGBoost ML enhancement (default: true)
    weight: 0.4  # Weight of XGBoost classification vs basic patterns (0.0-1.0, higher = more ML influence)
    min_samples_for_training: 50  # Minimum samples needed to train XGBoost model
    retrain_interval_hours: 24  # How often to retrain the model (hours)
    n_estimators: 100  # Number of boosting rounds
    max_depth: 6  # Maximum tree depth
    learning_rate: 0.1  # Learning rate (step size shrinkage)


