/**
 * API client for IndexPilot backend
 * 
 * Types are auto-generated from FastAPI OpenAPI schema
 * See: lib/api-types.ts (generated by scripts/generate-types.js)
 */

// Import generated types from OpenAPI schema
import type { components } from './api-types';

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:8000";

// Fallback types (used if generated types not available)
export type PerformanceData = {
  timestamp: string;
  queryCount: number;
  avgLatency: number;
  p95Latency: number;
  indexHits: number;
  indexMisses: number;
};

export type IndexImpact = {
  indexName: string;
  tableName: string;
  fieldName: string;
  improvement: number;
  queryCount: number;
  beforeCost: number;
  afterCost: number;
};

export type IndexHealth = {
  indexName: string;
  tableName: string;
  bloatPercent: number;
  sizeMB: number;
  usageCount: number;
  lastUsed: string;
  healthStatus: "healthy" | "warning" | "critical";
};

export type HealthSummary = {
  totalIndexes: number;
  healthyIndexes: number;
  warningIndexes: number;
  criticalIndexes: number;
  totalSizeMB: number;
  avgBloatPercent: number;
};

// Use generated types from OpenAPI schema
export type PerformanceResponse = components['schemas']['PerformanceResponse'];
export type HealthResponse = components['schemas']['HealthResponse'];
export type ExplainStats = components['schemas']['ExplainStats'];

export type DecisionExplanation = {
  id: number;
  tenantId: number | null;
  tableName: string;
  fieldName: string;
  indexName: string;
  mutationType: string;
  wasCreated: boolean;
  reason: string;
  confidence: number;
  queriesAnalyzed: number;
  buildCost: number;
  queryCostBefore: number;
  queryCostAfter: number;
  improvementPct: number;
  costBenefitRatio: number;
  queryPatterns: string[];
  createdAt: string;
  mode: string;
};

export type DecisionsResponse = {
  decisions: DecisionExplanation[];
  summary: {
    totalDecisions: number;
    totalCreated: number;
    totalSkipped: number;
    creationRate: number;
  };
};

export type SystemHealthResponse = {
  status: "operational" | "degraded" | "critical" | "unknown";
  statusColor: "green" | "yellow" | "red" | "gray";
  overallStatus: string;
  systemStatus: string;
  components: Record<string, unknown>;
  warnings: string[];
  errors: string[];
  timestamp: number;
  error?: string;
};

/**
 * Fetch performance data from API
 */
export async function fetchPerformanceData(): Promise<PerformanceResponse> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/performance`, {
      next: { revalidate: 30 }, // Revalidate every 30 seconds
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch performance data: ${response.statusText}`);
    }

    return (await response.json()) as PerformanceResponse;
  } catch (error) {
    console.error("Error fetching performance data:", error);
    throw error;
  }
}

/**
 * Fetch health data from API
 */
export async function fetchHealthData(): Promise<HealthResponse> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/health`, {
      next: { revalidate: 60 }, // Revalidate every 60 seconds
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch health data: ${response.statusText}`);
    }

    return (await response.json()) as HealthResponse;
  } catch (error) {
    console.error("Error fetching health data:", error);
    throw error;
  }
}

/**
 * Fetch EXPLAIN statistics from API
 */
export async function fetchExplainStats(): Promise<ExplainStats> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/explain-stats`, {
      next: { revalidate: 60 }, // Revalidate every 60 seconds
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch EXPLAIN stats: ${response.statusText}`);
    }

    return (await response.json()) as ExplainStats;
  } catch (error) {
    console.error("Error fetching EXPLAIN stats:", error);
    throw error;
  }
}

/**
 * Fetch decision explanations from API
 */
export async function fetchDecisionsData(limit: number = 50): Promise<DecisionsResponse> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/decisions?limit=${limit}`, {
      next: { revalidate: 60 }, // Revalidate every 60 seconds
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch decisions data: ${response.statusText}`);
    }

    return (await response.json()) as DecisionsResponse;
  } catch (error) {
    console.error("Error fetching decisions data:", error);
    throw error;
  }
}

/**
 * Fetch system health status from API
 */
export async function fetchSystemHealth(): Promise<SystemHealthResponse> {
  try {
    // Try the comprehensive system health endpoint first
    const response = await fetch(`${API_BASE_URL}/api/system-health`, {
      next: { revalidate: 30 }, // Revalidate every 30 seconds
    });

      if (!response.ok) {
        // If endpoint doesn't exist (404), fall back to basic health check
        if (response.status === 404) {
          const basicHealth = await fetch(`${API_BASE_URL}/`, {
            next: { revalidate: 30 },
          });
          if (basicHealth.ok) {
            // If basic health check works, assume system is operational
            // We don't need to parse the response, just check if it's ok
            return {
              status: "operational",
              statusColor: "green",
              overallStatus: "healthy",
              systemStatus: "operational",
              components: {},
              warnings: [],
              errors: [],
              timestamp: Date.now() / 1000,
            };
          }
        }
        throw new Error(`Failed to fetch system health: ${response.statusText}`);
      }

    return (await response.json()) as SystemHealthResponse;
  } catch (error) {
    console.error("Error fetching system health:", error);
    // Try basic health check as fallback
    try {
      const basicHealth = await fetch(`${API_BASE_URL}/`, {
        next: { revalidate: 30 },
      });
      if (basicHealth.ok) {
        return {
          status: "operational",
          statusColor: "green",
          overallStatus: "healthy",
          systemStatus: "operational",
          components: {},
          warnings: [],
          errors: [],
          timestamp: Date.now() / 1000,
        };
      }
    } catch {
      // Ignore fallback errors
    }
    // Return degraded status only if both endpoints fail
    return {
      status: "degraded",
      statusColor: "yellow",
      overallStatus: "error",
      systemStatus: "unknown",
      components: {},
      warnings: [],
      errors: [error instanceof Error ? error.message : "Failed to fetch system health"],
      timestamp: 0,
      error: error instanceof Error ? error.message : "Unknown error",
    };
  }
}
