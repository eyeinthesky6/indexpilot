/**
 * API client for IndexPilot backend
 * 
 * Types are auto-generated from FastAPI OpenAPI schema
 * See: lib/api-types.ts (generated by scripts/generate-types.js)
 */

// Import generated types from OpenAPI schema
import type { components } from './api-types';

const API_BASE_URL = process.env.NEXT_PUBLIC_API_URL || "http://localhost:8000";

// Fallback types (used if generated types not available)
export type PerformanceData = {
  timestamp: string;
  queryCount: number;
  avgLatency: number;
  p95Latency: number;
  indexHits: number;
  indexMisses: number;
};

export type IndexImpact = {
  indexName: string;
  tableName: string;
  fieldName: string;
  improvement: number;
  queryCount: number;
  beforeCost: number;
  afterCost: number;
};

export type IndexHealth = {
  indexName: string;
  tableName: string;
  bloatPercent: number;
  sizeMB: number;
  usageCount: number;
  lastUsed: string;
  healthStatus: "healthy" | "warning" | "critical";
};

export type HealthSummary = {
  totalIndexes: number;
  healthyIndexes: number;
  warningIndexes: number;
  criticalIndexes: number;
  totalSizeMB: number;
  avgBloatPercent: number;
};

// Use generated types from OpenAPI schema
export type PerformanceResponse = components['schemas']['PerformanceResponse'];
export type HealthResponse = components['schemas']['HealthResponse'];
export type ExplainStats = components['schemas']['ExplainStats'];

export type DecisionExplanation = {
  id: number;
  tenantId: number | null;
  tableName: string;
  fieldName: string;
  indexName: string;
  mutationType: string;
  wasCreated: boolean;
  reason: string;
  confidence: number;
  queriesAnalyzed: number;
  buildCost: number;
  queryCostBefore: number;
  queryCostAfter: number;
  improvementPct: number;
  costBenefitRatio: number;
  queryPatterns: string[];
  createdAt: string;
  mode: string;
};

export type DecisionsResponse = {
  decisions: DecisionExplanation[];
  summary: {
    totalDecisions: number;
    totalCreated: number;
    totalSkipped: number;
    creationRate: number;
  };
};

/**
 * Fetch performance data from API
 */
export async function fetchPerformanceData(): Promise<PerformanceResponse> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/performance`, {
      next: { revalidate: 30 }, // Revalidate every 30 seconds
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch performance data: ${response.statusText}`);
    }

    return (await response.json()) as PerformanceResponse;
  } catch (error) {
    console.error("Error fetching performance data:", error);
    throw error;
  }
}

/**
 * Fetch health data from API
 */
export async function fetchHealthData(): Promise<HealthResponse> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/health`, {
      next: { revalidate: 60 }, // Revalidate every 60 seconds
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch health data: ${response.statusText}`);
    }

    return (await response.json()) as HealthResponse;
  } catch (error) {
    console.error("Error fetching health data:", error);
    throw error;
  }
}

/**
 * Fetch EXPLAIN statistics from API
 */
export async function fetchExplainStats(): Promise<ExplainStats> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/explain-stats`, {
      next: { revalidate: 60 }, // Revalidate every 60 seconds
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch EXPLAIN stats: ${response.statusText}`);
    }

    return (await response.json()) as ExplainStats;
  } catch (error) {
    console.error("Error fetching EXPLAIN stats:", error);
    throw error;
  }
}

/**
 * Fetch decision explanations from API
 */
export async function fetchDecisionsData(limit: number = 50): Promise<DecisionsResponse> {
  try {
    const response = await fetch(`${API_BASE_URL}/api/decisions?limit=${limit}`, {
      next: { revalidate: 60 }, // Revalidate every 60 seconds
    });

    if (!response.ok) {
      throw new Error(`Failed to fetch decisions data: ${response.statusText}`);
    }

    return (await response.json()) as DecisionsResponse;
  } catch (error) {
    console.error("Error fetching decisions data:", error);
    throw error;
  }
}
